package gengo

import (
	"fmt"
	"iter"
	"net/http"
	"strconv"
	"strings"

	"google.golang.org/genproto/googleapis/api/annotations"
	"google.golang.org/grpc/grpclog"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/pluginpb"

	"github.com/wjiec/alchemy/cmd/protoc-gen-alchemy/internal/gengo/pattern"
)

var (
	Version = "v0.0.0"
)

// SupportedFeatures reports the set of supported protobuf language features
var SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)

// GenerateFile generates the contents of a .alchemy.go file
func GenerateFile(gen *protogen.Plugin, file *protogen.File) error {
	if len(file.Services) == 0 {
		return nil
	}

	filename := file.GeneratedFilenamePrefix + ".pb.alchemy.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	genGeneratedHeader(g, file)
	genVersionHeader(g, gen)
	genGoPackageHeader(g, file)
	for _, service := range file.Services {
		genServiceRegister(g, service)
		if err := genServiceDesc(g, service); err != nil {
			return err
		}
	}

	return nil
}

func genGeneratedHeader(g *protogen.GeneratedFile, file *protogen.File) {
	g.P("// Code generated by protoc-gen-alchemy. DO NOT EDIT.")
	g.P("// source: ", file.Desc.Path())
	g.P()
}

func genVersionHeader(g *protogen.GeneratedFile, gen *protogen.Plugin) {
	g.P("// protoc: ", compilerVersion(gen))
	g.P("// protoc-gen-go-alchemy: ", Version)
	g.P()
}

func genGoPackageHeader(g *protogen.GeneratedFile, file *protogen.File) {
	g.P("package ", file.GoPackageName)
	g.P()
}

var (
	alchemyPackage = protogen.GoImportPath("github.com/wjiec/alchemy")
)

func genServiceRegister(g *protogen.GeneratedFile, service *protogen.Service) {
	serviceRegistrarType := alchemyPackage.Ident("ServiceRegistrar")

	registerFuncName := "Register" + service.GoName + "AlchemyServer"
	g.P("// ", registerFuncName, " registers the ", service.GoName, " with the Alchemy's ServiceRegistrar.")
	g.P("func ", registerFuncName, "(s ", serviceRegistrarType, ", srv ", service.GoName, "Server) {")
	{
		g.P("s.RegisterService(&", serviceDescVar(service), ", srv)")
	}
	g.P("}")
}

func genServiceDesc(g *protogen.GeneratedFile, service *protogen.Service) error {
	g.P("// "+serviceDescVar(service), " defines the Alchemy service descriptor for the ", service.GoName, " service.")
	g.P("var ", serviceDescVar(service), " = ", alchemyPackage.Ident("ServiceDesc"), "{")
	{
		g.P("GrpcServiceDesc: &", service.GoName+"_ServiceDesc,")
		g.P("Routes: []", alchemyPackage.Ident("RouteDesc"), "{")
		for _, method := range service.Methods {
			for rule := range visitHttpRules(method.Desc.Options()) {
				httpMethod, pathPattern := parseMethodWithPattern(rule)
				g.P("{")
				{
					g.P("HttpMethod: ", strconv.Quote(httpMethod), ",")
					g.P("PathPattern: ", strconv.Quote(pathPattern), ",")
					g.P("Handler: _", service.GoName, "_", method.GoName, "_Handler,")
					if len(rule.Body) != 0 && rule.Body != "*" {
						g.P("RequestField: ", alchemyPackage.Ident("KeyPath"), "{")
						{
							g.P("Name: ", strconv.Quote(rule.Body), ",")

							goFieldPath, err := resolveGoFieldPath(method.Input, rule.Body)
							if err != nil {
								return err
							}
							g.P("Accessor: func(v any) any { return &v.(*", method.Input.GoIdent, ").", strings.Join(goFieldPath, "."), " },")
						}
						g.P("},")
					}
					if len(rule.ResponseBody) != 0 && rule.ResponseBody != "*" {
						g.P("ResponseField: ", alchemyPackage.Ident("KeyPath"), "{")
						{
							g.P("Name: ", strconv.Quote(rule.ResponseBody), ",")

							goFieldPath, err := resolveGoFieldPath(method.Output, rule.ResponseBody)
							if err != nil {
								return err
							}
							g.P("Accessor: func(v any) any { return &v.(*", method.Output.GoIdent, ").", strings.Join(goFieldPath, "."), " },")
						}
						g.P("},")
					}

					pathParameterNames, err := pattern.Parse(pathPattern)
					if err != nil {
						return err
					}
					if len(pathParameterNames) != 0 {
						g.P("PathParameters: ", fmt.Sprintf("%#v", pathParameterNames), ",")
					}
				}
				g.P("},")
			}
		}
		g.P("},")
	}
	g.P("}")

	return nil
}

func serviceDescVar(service *protogen.Service) string {
	return "_" + service.GoName + "_AlchemyServiceDesc"
}

func visitHttpRules(options proto.Message) iter.Seq[*annotations.HttpRule] {
	queue := make([]*annotations.HttpRule, 0, 32)
	queue = append(queue, proto.GetExtension(options, annotations.E_Http).(*annotations.HttpRule))
	return func(yield func(*annotations.HttpRule) bool) {
		for len(queue) != 0 {
			curr := queue[0]
			queue = append(queue[1:], curr.AdditionalBindings...)

			if !yield(curr) {
				return
			}
		}
	}
}

func parseMethodWithPattern(rule *annotations.HttpRule) (string, string) {
	switch v := rule.Pattern.(type) {
	case *annotations.HttpRule_Get:
		return http.MethodGet, v.Get
	case *annotations.HttpRule_Put:
		return http.MethodPut, v.Put
	case *annotations.HttpRule_Post:
		return http.MethodPost, v.Post
	case *annotations.HttpRule_Delete:
		return http.MethodDelete, v.Delete
	case *annotations.HttpRule_Patch:
		return http.MethodPatch, v.Patch
	case *annotations.HttpRule_Custom:
		return v.Custom.Kind, v.Custom.Path
	default:
		return "", ""
	}
}

func compilerVersion(gen *protogen.Plugin) string {
	ver := gen.Request.GetCompilerVersion()
	if ver == nil {
		return "(unknown)"
	}

	var suffix string
	if s := ver.GetSuffix(); s != "" {
		suffix = "-" + s
	}

	return fmt.Sprintf("v%d.%d.%d%s",
		ver.GetMajor(), ver.GetMinor(), ver.GetPatch(), suffix)
}

func lookupField(msg *protogen.Message, name string) *protogen.Field {
	for _, field := range msg.Fields {
		if string(field.Desc.Name()) == name {
			return field
		}
	}
	return nil
}

func resolveGoFieldPath(msg *protogen.Message, path string) ([]string, error) {
	var res []string
	for _, elem := range strings.Split(path, ".") {
		if grpclog.V(2) {
			grpclog.Infof("Lookup %s in %s", elem, msg.Desc.FullName())
		}

		field := lookupField(msg, elem)
		if field == nil {
			return nil, fmt.Errorf("no field %q found in %s", elem, msg.Desc.Name())
		}

		res = append(res, field.GoName)
		msg = field.Message
	}

	return res, nil
}
